<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lezione 24: JPQL con JPA e Hibernate e Testing delle entit√†</title>
    <link rel="stylesheet" href="../styles/style.css">
</head>
<body>
<h1 class="lesson-title">Lezione 24: JPQL con JPA e Hibernate e Testing delle entit√†</h1>

<!-- Introduzione -->
<div class="section">
    <h2>Introduzione</h2>
    <p>
        In questa lezione esploreremo in dettaglio **JPA (Java Persistence API)** e **Hibernate**, due strumenti fondamentali per la persistenza dei dati in applicazioni Java. JPA √® una specifica che definisce un'interfaccia standard per lavorare con database relazionali in modo orientato agli oggetti, mentre **Hibernate** √® una delle implementazioni pi√π diffuse di JPA, fornendo funzionalit√† avanzate per la gestione delle entit√† e delle transazioni.
    </p>

    <p>
        L'uso di JPA con Hibernate permette agli sviluppatori di lavorare con il database senza scrivere direttamente codice SQL, grazie a un modello di **mappatura Object-Relational Mapping (ORM)**. Questo approccio migliora l'organizzazione del codice, riduce la dipendenza dal database specifico e aumenta la manutenibilit√† delle applicazioni.
    </p>

    <p>
        Inoltre, approfondiremo **JPQL (Java Persistence Query Language)**, un linguaggio di interrogazione simile a SQL ma progettato per interagire con entit√† Java invece che con le tabelle del database. JPQL consente di eseguire query in modo pi√π espressivo e naturale rispetto al SQL tradizionale, sfruttando la logica dell'orientamento agli oggetti.
    </p>

    <p>
        Infine, per garantire l'integrit√† e l'affidabilit√† della persistenza dei dati, vedremo come testare le entit√† utilizzando **JUnit** e **TestContainers**. Questi strumenti permettono di eseguire test in un ambiente isolato e realistico, assicurando che l'interazione tra il codice Java e il database avvenga correttamente prima di distribuire l'applicazione in produzione.
    </p>

    <p>
        Durante questa lezione, metteremo in pratica i concetti con esempi concreti, spiegando come configurare JPA e Hibernate, eseguire query JPQL e testare le entit√† in un ambiente controllato. L'obiettivo √® fornire una comprensione chiara e approfondita delle migliori pratiche per la gestione della persistenza dei dati in un'applicazione Java moderna.
    </p>
</div>


<!-- Sezione JPQL con JPA e Hibernate -->
<div class="section">
    <h2>1. Utilizzo di JPQL nel Repository</h2>
    <p>
        JPQL (Java Persistence Query Language) √® un linguaggio di query orientato agli oggetti che consente di interrogare il database utilizzando il modello delle entit√†. Invece di interagire direttamente con l‚Äô<code>EntityManager</code> per eseguire query SQL, definiamo metodi personalizzati nel layer repository sfruttando l‚Äôannotazione <code>@Query</code> in interfacce che estendono <code>JpaRepository</code>.
    </p>
    <p>
        Questo approccio porta numerosi vantaggi:
    </p>
    <ul>
        <li><strong>Isolamento della logica di accesso ai dati:</strong> Il repository incapsula tutte le operazioni di persistenza, mantenendo separate la logica di business e la gestione del database.</li>
        <li><strong>Query orientate agli oggetti:</strong> Utilizzando i nomi delle entit√† e degli attributi (ad es. <code>User</code> e <code>email</code>), il codice diventa pi√π intuitivo e facilmente manutenibile, poich√© le modifiche al modello non richiedono riscritture estese del codice di accesso ai dati.</li>
        <li><strong>Portabilit√†:</strong> Poich√© JPQL opera sul modello delle entit√†, il codice √® meno vincolato a specifici DBMS. Questo migliora la portabilit√† e la flessibilit√†, permettendo di cambiare database senza dover riscrivere le query.</li>
    </ul>
    <p>
        L'esempio sottostante mostra un'interfaccia repository per l'entit√† <code>User</code> in cui vengono definite diverse query JPQL, insieme a un esempio di query native per evidenziare le differenze. Le query JPQL sfruttano le funzionalit√† offerte da Hibernate, mentre le query native permettono di accedere a funzionalit√† specifiche del database quando necessario.
    </p>
    <h3>Esempio: Repository per l'entit√† <code>User</code></h3>
    <p>
        Di seguito un esempio di interfaccia repository che definisce diverse query JPQL, oltre a un esempio di query native per evidenziare la differenza:
    </p>
    <pre><code>@Repository
public interface UserRepository extends JpaRepository&lt;User, Long&gt; {

    // Recupera tutti gli utenti attivi
    @Query("SELECT u FROM User u WHERE u.active = true")
    List&lt;User&gt; findActiveUsers();

    // Trova un utente per email utilizzando JPQL
    @Query("SELECT u FROM User u WHERE u.email = :email")
    User findByEmail(@Param("email") String email);

    // Conta il numero totale di utenti
    @Query("SELECT COUNT(u) FROM User u")
    Long countUsers();

    // Recupera gli utenti con pi√π di 5 ordini
    @Query("SELECT u FROM User u WHERE SIZE(u.orders) > 5")
    List&lt;User&gt; findUsersWithMoreThanFiveOrders();

    // Recupera un utente e i suoi ordini tramite JOIN FETCH
    @Query("SELECT u FROM User u JOIN FETCH u.orders WHERE u.email = :email")
    User findUserWithOrdersByEmail(@Param("email") String email);

    // Esempio di query native: la query viene scritta in SQL e fa riferimento direttamente alla tabella "users"
    @Query(value = "SELECT * FROM users WHERE email = :email", nativeQuery = true)
    User findByEmailNative(@Param("email") String email);
}
</code></pre>
    <h3>Differenze tra Query JPQL e Query Native</h3>
    <p>
        Le query definite con <code>@Query</code> in JPQL operano sul modello delle entit√†, sfruttando i nomi delle classi e degli attributi, e permettono di utilizzare le funzionalit√† ORM offerte da Hibernate. Questo rende il codice pi√π astratto e facilmente adattabile a modifiche future, poich√© l'attenzione √® rivolta agli oggetti e non alle tabelle del database.
    </p>
    <p>
        Al contrario, le query native sono scritte in SQL e si riferiscono direttamente alle tabelle e alle colonne del database. Pur offrendo un maggiore controllo e l'accesso a funzionalit√† specifiche del DBMS, esse riducono l'astrazione e la portabilit√† del codice. Di solito, si ricorre alle query native solo in casi particolari in cui le limitazioni di JPQL non permettono di esprimere la logica necessaria.
    </p>
    <p>
        In sintesi, si consiglia di preferire JPQL per mantenere il codice pulito, portabile e orientato agli oggetti, utilizzando le query native solo quando strettamente necessario.
    </p>
</div>

<!-- Sezione Testing delle entit√† -->
<div class="section">
    <h2>2. Testing delle entit√† con JUnit e TestContainers</h2>
    <p>
        Garantire il corretto funzionamento del layer repository √® essenziale per la qualit√† complessiva dell'applicazione. In questo contesto, i test di integrazione svolgono un ruolo fondamentale nel verificare che le query personalizzate e le operazioni di persistenza interagiscano correttamente con il database.
    </p>
    <p>
        Utilizzando <code>@SpringBootTest</code>, l'intero contesto applicativo viene caricato, permettendo l'iniezione delle dipendenze e la simulazione di un ambiente reale. TestContainers consente di avviare in modo semplice un container Docker con PostgreSQL, offrendo un ambiente di test isolato e replicabile, che elimina le dipendenze dall'ambiente locale e riduce il rischio di errori dovuti a configurazioni differenti.
    </p>
    <div class="example">
        <h3>Esempio: Test di integrazione per <code>UserRepository</code></h3>
        <pre><code>import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.AfterAll;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.testcontainers.containers.PostgreSQLContainer;
import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest
public class UserRepositoryTest {

    @Autowired
    private UserRepository userRepository;

    private static PostgreSQLContainer&lt;?&gt; postgresContainer;

    @BeforeAll
    public static void setUp() {
        postgresContainer = new PostgreSQLContainer<>("postgres:15")
                            .withDatabaseName("testdb")
                            .withUsername("test")
                            .withPassword("test");
        postgresContainer.start();
        // Configurare le propriet√† del datasource se necessario
    }

    @AfterAll
    public static void tearDown() {
        postgresContainer.stop();
    }

    @Test
    public void testFindActiveUsers() {
        // Creazione e salvataggio di un utente attivo
        User user = User.builder()
                        .nome("Mario Rossi")
                        .email("mario.rossi@example.com")
                        .active(true)
                        .build();
        userRepository.save(user);

        List&lt;User&gt; activeUsers = userRepository.findActiveUsers();
        assertFalse(activeUsers.isEmpty());
        assertEquals("Mario Rossi", activeUsers.get(0).getNome());
    }
}
</code></pre>
    </div>
    <p>
        Questi test dimostrano come verificare non solo la correttezza delle query, ma anche l'integrazione complessiva con un database reale. L'uso di TestContainers consente di simulare un ambiente di produzione in maniera automatizzata, assicurando che le funzionalit√† implementate nel repository rispondano in modo affidabile e consistente anche in situazioni reali.
    </p>
</div>



<!-- Sezione Test -->
<div class="section">
    <div class="test">
        <h3>Test e Verifica della Comprensione</h3>
        <p>
            Rispondi alle seguenti domande per consolidare la tua comprensione sull'uso di **JPQL, JPA, Hibernate** e
            le tecniche di testing delle entit√†. Rifletti sui concetti trattati e verifica se sei in grado di spiegare
            i principi fondamentali di questi strumenti.
        </p>
        <ul>
            <li>
                ‚úÖ **Qual √® la differenza fondamentale tra JPQL e SQL tradizionale?**<br>
                *Spiega come JPQL opera sulle entit√† Java anzich√© sulle tabelle del database e quali vantaggi offre rispetto al SQL nativo.*
            </li>
            <li>
                ‚úÖ **Come viene configurato l‚Äô<code>EntityManagerFactory</code> per utilizzare Hibernate come provider JPA?**<br>
                *Descrivi i passaggi chiave nella configurazione di JPA, inclusa la definizione del file <code>persistence.xml</code> e
                l'impostazione delle propriet√† di connessione al database.*
            </li>
            <li>
                ‚úÖ **In che modo Hibernate semplifica l'interazione con il database quando si usa JPQL?**<br>
                *Analizza il ruolo di Hibernate nella gestione automatica delle transazioni, delle query e delle associazioni tra entit√†.*
            </li>
            <li>
                ‚úÖ **Quali vantaggi offre l‚Äôuso di TestContainers nel testing delle entit√†?**<br>
                *Illustra i benefici di testare le entit√† in un ambiente containerizzato rispetto a un database in-memory o a un database fisico.*
            </li>
        </ul>
        <p>
            Dopo aver risposto a queste domande, prova a implementare alcuni test pratici per verificare le tue conoscenze
            in un progetto reale. üîçüõ†Ô∏è
        </p>
    </div>
</div>


<!-- Sezione Bibliografia -->
<div class="bibliography">
    <h2>Bibliografia e Risorse Utili</h2>
    <p>
        Per approfondire gli argomenti trattati in questa lezione, consulta le seguenti risorse ufficiali e guide dettagliate.
        Questi riferimenti ti aiuteranno a migliorare la comprensione di **JPA, JPQL, Hibernate, JUnit e TestContainers**. üìñ
    </p>
    <ul>
        <li>
            üîó <a href="https://docs.oracle.com/javaee/7/tutorial/persistence-querylanguage.htm" target="_blank">
            Documentazione ufficiale di JPQL - Oracle</a> <br>
            *Guida completa all'uso di JPQL secondo la specifica ufficiale di JPA.*
        </li>
        <li>
            üîó <a href="https://www.baeldung.com/hibernate-jpql" target="_blank">
            Introduzione a Hibernate e JPQL - Baeldung</a> <br>
            *Un tutorial pratico che spiega come utilizzare JPQL con Hibernate e le differenze rispetto a SQL tradizionale.*
        </li>
        <li>
            üîó <a href="https://junit.org/junit5/" target="_blank">
            JUnit 5 - Documentazione ufficiale</a> <br>
            *Guida completa per scrivere test unitari e di integrazione in Java utilizzando JUnit 5.*
        </li>
        <li>
            üîó <a href="https://www.testcontainers.org/" target="_blank">
            TestContainers - Documentazione ufficiale</a> <br>
            *Tutto ci√≤ che devi sapere per configurare e utilizzare TestContainers nei tuoi test di integrazione.*
        </li>
        <li>
            üîó <a href="https://www.baeldung.com/jpa-criteria-api" target="_blank">
            Guida alla Criteria API - Baeldung</a> <br>
            *Una panoramica sull‚Äôuso della Criteria API per scrivere query JPA dinamiche senza usare JPQL.*
        </li>
    </ul>
    <p>
        üìå **Suggerimento:** Dopo aver letto la documentazione, metti in pratica i concetti creando un progetto
        che utilizza **Hibernate e JPQL** con **JUnit e TestContainers** per testare il funzionamento delle entit√†. üöÄ
    </p>
</div>


<!-- Sezione Approfondimenti -->
<div class="advanced">
    <h2>Approfondimenti e Temi Avanzati</h2>
    <p>
        Per chi vuole approfondire ulteriormente, ecco alcuni argomenti avanzati che ti permetteranno di migliorare
        le tue competenze con **JPA, Hibernate e il testing delle entit√†**. Esplora queste tematiche per scrivere codice
        pi√π efficiente e ottimizzato. üî¨
    </p>
    <ul>
        <li>
            üõ†Ô∏è **Criteria API: Costruzione di query programmatiche** <br>
            *La Criteria API √® un'alternativa potente a JPQL, consentendo di costruire query dinamiche in modo tipizzato.*
            <br>üëâ Approfondisci: <a href="https://www.baeldung.com/jpa-criteria-api" target="_blank">Guida Baeldung sulla Criteria API</a>
        </li>
        <li>
            ‚ö° **Ottimizzazione delle query con Hibernate** <br>
            *Scopri le migliori pratiche per scrivere query JPQL efficienti, sfruttando **cache di primo e secondo livello**,
            **fetch strategies** e **batch fetching** per migliorare le prestazioni dell‚Äôapplicazione.*
        </li>
        <li>
            üèóÔ∏è **Configurazioni avanzate di TestContainers** <br>
            *Personalizzazione dei container per testare scenari complessi, come la configurazione di **database multiistanza**,
            **test concorrenti** e l'uso di **immagini personalizzate**.*
            <br>üëâ Approfondisci: <a href="https://www.testcontainers.org/modules/databases/" target="_blank">Guida ufficiale TestContainers</a>
        </li>
        <li>
            üå± **Integrazione di JPA con Spring Boot** <br>
            *Scopri come **Spring Data JPA** semplifica la configurazione di Hibernate e il testing delle entit√† in un'applicazione Spring Boot.*
            <br>üëâ Approfondisci: <a href="https://www.baeldung.com/the-persistence-layer-with-spring-data-jpa" target="_blank">
            Persistence Layer con Spring Data JPA - Baeldung</a>
        </li>
    </ul>
    <p>
        üìå **Sfida:** Implementa un sistema che utilizzi **Hibernate, JPQL, TestContainers e Criteria API** per testare operazioni CRUD
        e query avanzate su un database containerizzato. üöÄ
    </p>
</div>




<!-- Footer -->
<footer class="footer">
    <a href="../index.html" class="footer-logo">
        <img src="../img/logo.png" alt="Logo del sito" />
    </a>
    <div class="footer-links">
        <a href="../Settimana_5/Esercitazione_4/Esercitazione_4.html" class="footer-link left">
            &#8592; Pagina precedente
        </a>
        <a href="../Settimana_5/Lezione_27.html" class="footer-link right">
            Pagina successiva &#8594;
        </a>
    </div>
    &copy; 2025 Corso di Programmazione Backend. Tutti i diritti riservati.
</footer>
</body>
</html>
