
<!DOCTYPE html>

<html lang="it">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Lezione 4: Programmazione Orientata agli Oggetti</title>
<link href="/styles/style.css" rel="stylesheet"/>
</head>
<body>
<h1>Giorno 4: Programmazione Orientata agli Oggetti</h1>
<section class="intro">
<p>Oggi approfondiremo la Programmazione Orientata agli Oggetti (OOP), un paradigma di programmazione
            fondamentale per lo sviluppo di applicazioni modulari e scalabili. L'OOP consente di rappresentare concetti
            e processi utilizzando classi e oggetti, favorendo la manutenibilità e il riutilizzo del codice.</p>
</section>
<h2>Argomenti della Lezione</h2>
<h3>1. Introduzione alla Programmazione Orientata agli Oggetti</h3>
<p>L'OOP si basa su quattro pilastri principali: astrazione, incapsulamento, ereditarietà e polimorfismo. Questi
        concetti permettono di progettare sistemi software complessi modellandoli su entità del mondo reale. Vediamo i
        concetti principali:</p>
<ul>
<li><strong>Astrazione:</strong> Processo di rappresentazione degli aspetti essenziali di un'entità senza
            includere dettagli irrilevanti.</li>
<li><strong>Incapsulamento:</strong> Meccanismo di nascondere i dettagli di implementazione e fornire accesso
            solo attraverso metodi pubblici.</li>
<li><strong>Ereditarietà:</strong> Possibilità di definire nuove classi basandosi su classi esistenti,
            ereditandone attributi e comportamenti.</li>
<li><strong>Polimorfismo:</strong> Capacità di utilizzare oggetti di tipi diversi attraverso un'unica
            interfaccia.</li>
</ul>
<div class="example">
<strong>Esempio:</strong> Rappresentare un'auto in Java.
        <pre><code>public class Auto {
    String marca;
    String modello;
    int anno;

    public void accendi() {
        System.out.println("L'auto è accesa.");
    }

    public void spegni() {
        System.out.println("L'auto è spenta.");
    }
}

public class Main {
    public static void main(String[] args) {
        Auto miaAuto = new Auto();
        miaAuto.marca = "Fiat";
        miaAuto.modello = "Punto";
        miaAuto.anno = 2020;
        miaAuto.accendi();
    }
}</code></pre>
</div>
<h3>2. Ereditarietà</h3>
<p>Con l'ereditarietà, possiamo creare nuove classi che riutilizzano il comportamento di classi esistenti. Questo
        permette di estendere le funzionalità senza duplicare il codice.</p>
<div class="example">
<strong>Esempio:</strong> Estendere la classe Auto per creare una classe AutoElettrica.
        <pre><code>public class AutoElettrica extends Auto {
    int capacitaBatteria;

    public void ricarica() {
        System.out.println("Ricaricando l'auto...");
    }
}

public class Main {
    public static void main(String[] args) {
        AutoElettrica tesla = new AutoElettrica();
        tesla.marca = "Tesla";
        tesla.modello = "Model S";
        tesla.capacitaBatteria = 100;
        tesla.ricarica();
    }
}</code></pre>
</div>
<h3>3. Polimorfismo</h3>
<p>Il polimorfismo consente di trattare oggetti di classi diverse in modo uniforme. Questo è possibile grazie
        all'ereditarietà e all'override dei metodi.</p>
<div class="example">
<strong>Esempio:</strong> Utilizzare il polimorfismo con classi derivate.
        <pre><code>public class Veicolo {
    public void avvia() {
        System.out.println("Il veicolo sta partendo.");
    }
}

public class Moto extends Veicolo {
    @Override
    public void avvia() {
        System.out.println("La moto sta partendo.");
    }
}

public class Main {
    public static void main(String[] args) {
        Veicolo veicolo = new Moto();
        veicolo.avvia();
    }
}</code></pre>
</div>
<h3>4. Incapsulamento</h3>
<p>Attraverso l'incapsulamento, proteggiamo i dati sensibili della classe rendendoli accessibili solo tramite metodi
        specifici, noti come getter e setter.</p>
<div class="example">
<strong>Esempio:</strong> Utilizzare getter e setter.
        <pre><code>public class Persona {
    private String nome;

    public String getNome() {
        return nome;
    }

    public void setNome(String nome) {
        this.nome = nome;
    }
}

public class Main {
    public static void main(String[] args) {
        Persona persona = new Persona();
        persona.setNome("Mario");
        System.out.println("Nome: " + persona.getNome());
    }
}</code></pre>
</div>
<section class="bibliography">
<h3>Bibliografia</h3>
<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/java/concepts/index.html" target="_blank">Concetti di
                    base di Java - Oracle</a></li>
<li><a href="https://www.baeldung.com/java-object-oriented-programming" target="_blank">Guida OOP in Java -
                    Baeldung</a></li>
</ul>
</section>
<section class="advanced">
    <h2>Approfondimenti</h2>
    <p>Per gli studenti più avanzati, esploriamo le seguenti tematiche:</p>
    <ul>
        <li>Analisi delle performance delle principali implementazioni delle collezioni</li>
        <li>Uso dei metodi avanzati nelle collezioni, come <code>computeIfAbsent</code> e <code>replaceAll</code> in <code>Map</code></li>
        <li>Personalizzazione di collezioni tramite classi anonime o lambda</li>
        <li>Introduzione alle collezioni immutabili in Java 9 e successivi</li>
    </ul>
    <p>Esempio di utilizzo di <code>computeIfAbsent</code>:</p>
    <pre><code class="language-java">import java.util.HashMap;

public class Main {
public static void main(String[] args) {
HashMap<String, Integer> wordCounts = new HashMap<>();

String[] words = {"apple", "banana", "apple", "orange", "banana", "apple"};
for (String word : words) {
    wordCounts.computeIfAbsent(word, k -> 0);
    wordCounts.put(word, wordCounts.get(word) + 1);
}

wordCounts.forEach((word, count) -> System.out.println(word + ": " + count));
}
}</code></pre>

    <h3>Note sulle classi List e Map</h3>
    <p><strong>List:</strong> La classe List rappresenta una sequenza ordinata di elementi. È possibile accedere agli elementi tramite un indice e possono essere presenti duplicati. Implementazioni comuni includono:</p>
    <ul>
        <li><code>ArrayList</code>: Ottimizzata per accessi rapidi agli elementi tramite indice.</li>
        <li><code>LinkedList</code>: Ideale per inserimenti e rimozioni frequenti, grazie alla sua struttura a nodi collegati.</li>
    </ul>
    <p><strong>Map:</strong> La classe Map memorizza coppie chiave-valore, dove ogni chiave è unica. Le implementazioni comuni sono:</p>
    <ul>
        <li><code>HashMap</code>: Offre prestazioni elevate per operazioni di ricerca, inserimento e rimozione.</li>
        <li><code>TreeMap</code>: Ordina le chiavi in base all'ordine naturale o a un comparatore specificato.</li>
    </ul>
</section>
<footer class="footer">
<a class="footer-logo" href="/index.html">
<img alt="Logo del sito" src="/img/logo.png"/>
</a>
<div class="footer-links">
<a class="footer-link left" href="/Settimana_1/Lezione_3.html">
                ← Pagina precedente
            </a>
<a class="footer-link right" href="/Settimana_1/Esercitazione/Esercitazione_1.html">
                Pagina successiva →
            </a>
</div>
        © 2025 Corso di Programmazione Backend. Tutti i diritti riservati.
    </footer>
</body>
</html>